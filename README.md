# Runner

## Принципы SOLID:
- Принцип единой ответственности: каждый класс отвечает за определённую задачу. Например, классы Coin, Obstacle и Player реализуют функциональность соответствующих им игровых элементов.
- Принцип открытости/закрытости: классы проектируются таким образом, чтобы быть готовыми к расширению и закрытыми для изменений. Это достигается за счет использования интерфейсов, наследования и различных шаблонов.
- Принцип подстановки Барбары Лисков: все классы, производные от BaseItemsEffect, могут быть заменены на базовый класс без изменения его функциональности.
- Принцип разделения интерфейсов: интерфейсы (IItemsEffect, IPool, IGameViewObserver) разделены на небольшие, логически завершенные части.
- Принцип инверсии зависимостей: такие классы, как ItemsGenerator и Player, зависят от абстракций (IItemsEffect, IGameViewObserver), а не от конкретных реализаций.

## Архитектурные решения :
- Паттерн пул объектов: используется для повторного использования объектов (ObjectPool).
- Фабричный метод: используется для создания различных типов объектов (ItemsFactory), что делает систему более гибкой, лёгкой и удобной для поддержки по мере добавления новых объектов.
- Асинхронность: async/await используется для реализации эффектов с таймерами (WaitUntilTimeRunsOut), что позволяет осуществлять асинхронное ожидание и обновление состояния игры.

## Особенности выбора :
- Интерфейсы: использование интерфейсов позволяет легко добавлять новые реализации функциональности без модификации существующего кода.
- Пул объектов: эффективно управляет созданием и уничтожением объектов, снижая нагрузку на сборщик мусора и повышая производительность.
- Фабричный метод: повышает расширяемость приложения, облегчая добавление новых элементов без модификации существующего кода.
- Асинхронность: позволяет управлять таймерами и анимацией, не препятствуя блокировке основного потока выполнения, предотвращая "замораживание" игрового процесса.